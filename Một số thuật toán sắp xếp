#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

// Sắp xếp chèn
// Độ phức tạp thời gian: n^2
void insertion_sort(int a[], int n) {
    for(int i = 1 ; i < n ; i++) {
        int save = a[i], pos = i - 1;
        while(pos >= 0 && save < a[pos]) {
            a[pos + 1] = a[pos];
            pos--; 
        }
        a[pos + 1] = save;
    }
}

// Sắp xếp chọn
// Độ phức tạp thời gian: n^2
void selection_sort(int a[], int n) {
    for(int i = 0 ; i < n - 1 ; i++) {
        for(int j = i + 1 ; j < n ; j++) {
            if(a[i] < a[j]) {
                swap(a[i], a[j]);
            }
        }
    }
}

// Sắp xếp nổi bọt
// Độ phức tạp thời gian: n^2
void bubble_sort(int a[], int n) {
    for(int i = 0 ; i < n - 1 ; i++) {
        for(int j = 0 ; j < n - i - 1 ; j++) {
            if (a[j] > a[j + 1]) {
                swap(a[j], a[j + 1]);
            }
        }
    }
}

// Sắp xếp phân phối
// Độ phức tạp thời gian: n + k (k là phần tử lớn nhất trong mảng)
void counting_sort(int a[], int n) {
    int save[10000];
    int m = 0;
    for(int i = 0 ; i < n ; i++) {
        save[a[i]]++;
        m = max(m, a[i]);
    }
    int i = 0;
    for(int k = 0 ; k <= m ; k++) {
        if(save[k] != 0) {
            for(int j = 0 ; j < save[k] ; j++) {
                a[i] = k;
                i++;
            }
        }
    }
}

// Sắp xếp trộn
// Độ phức tạp thời gian: n * log(n)
void merge(int a[] , int left, int middle, int right) {
    vector <int> v1(a + left, a + middle + 1);
    vector <int> v2(a + middle + 1, a + right + 1);

    int i = 0, j = 0;
    while(i < v1.size() && j < v2.size()) {
        if(v1[i] < v2[j]) {
            a[left] = v1[i];
            i++, left++;
        }
        else {
            a[left] = v2[j];
            j++, left++;
        }
    }
    while (i < v1.size()) {
        a[left] = v1[i];
        i++, left++;
    }
    while(j < v2.size()) {
        a[left] = v2[j];
        j++, left++;
    }
}

void merge_sort(int a[], int left, int right) {
    if(left >= right) return;
    int middle = ((left + right) / 2);
    merge_sort(a, left, middle);
    merge_sort(a, middle + 1, right);
    merge(a, left, middle, right);
}

// Sắp xếp vun đống
// Độ phức tạp thời gian: n * log(n)
void heapify(int a[], int n, int i) {
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    int largest = i;
    if(left < n && a[left] > a[largest]) {
        largest = left;
    } 
    if(right < n && a[right] > a[largest]) {
        largest = right;
    }
    if(largest != i) {
        swap(a[largest], a[i]);
        heapify(a, n, largest);
    }
}

void heap_sort(int a[], int n) {
    for(int i = 0 ; i <= ((n / 2) - 1) ; i++) {
        heapify(a, n, i);
    }
    for(int i = n - 1 ; i >= 0 ; i--) {
        int temp = a[i];
        a[i] = a[0];
        a[0] = temp;
        heapify(a, i, 0);
    } 
}

// Sắp xếp nhanh
// Hoare
// Độ phức tạp thời gian: n * log(n)
// Tốt hơn lomoto
int partition1(int a[], int left, int right) {
    int pivot = a[left];
    int i = left, j = right;
    while(true) {
        while(a[i] < pivot) {
            i++;
        }
        while(a[j] > pivot) {
            j--;
        }
        if(i < j) {
            swap(a[i], a[j]);
            i++, j--;
        }
        else {
            return j;
        }
    }
}

// Lomoto
// Độ phức tạp thời gian: n * log(n)
int partition2(int a[], int left, int right) {
    int pivot = a[right];
    int i = left - 1;
    for(int j = left ; j < right ; j++) {
        if(a[j] < pivot) {
            i++;
            swap(a[i], a[j]);
        }
    }
    i++;
    swap(a[i], a[right]);
    return i;
}

void quick_sort(int a[], int left, int right) {
    if(left >= right) return;
    int p = partition2(a, left, right);
    quick_sort(a, left, p - 1);
    quick_sort(a, p + 1, right);
}
int main () {
    int n = 10;
    int a[n] = {10,9,0,7,7,5,4,3,7,1};
    quick_sort(a, 0, n - 1);
     for(int i = 0 ; i < n ; i++) {
         cout << a[i] << " ";
    }
}
